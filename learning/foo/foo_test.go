package foo

import (
	"testing"
)

// func TestFooer(t *testing.T) {
// 	result := Fooer(3)

// 	if result != "Foo" {
// 		t.Errorf("expected Foo, got %s", result)
// 	}
// }

// func TestFooerTableDriven(t *testing.T) {
// 	var tests = []struct{
// 		name string
// 		input int
// 		want string
// 	}{
// 		{"3 should be Foo", 3, "Foo"},
// 		{"1 should be 1", 1, "1"},
// 		{"2 should be 2", 2, "2"},
// 	}

// 	// execute the tests
// 	for _, tt := range tests {
// 		t.Run(tt.name, func(t *testing.T){ // t.run runs a test with the given name and function
// 			ans := Fooer(tt.input)
// 			if ans != tt.want {
// 				t.Errorf("expected %s, got %s", tt.want, ans)
// 			}
// 		})
// 	}
// }

// automatically generated by VSCode
func TestFooer(t *testing.T) {
	type args struct {
		input int
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{"3 should be Foo", args{3}, "Foo"},
		{"1 should be 1", args{1}, "1"},
		{"2 should be 2", args{2}, "2"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Fooer(tt.args.input); got != tt.want {
				t.Errorf("Fooer() = %v, want %v", got, tt.want)
				// although the t.Errorf marks the test as failed, it does not stop them from running till the end
				// if you want to stop the  test, use t.Fatal* instead
				t.Fatal("test failed")
				t.Errorf("this line will not be printed")
			}
		})
	}
}

/// benchmanrs to test performance
func BenchmarkFooer(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Fooer(i)
	}
}

// fuzz testing is a type of testing that involves providing random data to a function and checking if it panics or not
// it does not check the output of the function, just if it panics or not
func FuzzFooer(f *testing.F) {
	f.Add(3) // initial seed
	f.Fuzz(func(t *testing.T, input int) {
		Fooer(input)
	})
}